<!DOCTYPE html>
<html lang="ko">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
   </head>
   <body>
      <script>
         /* 
          동기는 순서대로 작업을 하는것으로 실행이 끝날 때 까지 다른 일은 하지 않는다.
          비동기는 순서와 상관없이 작업을 하는것으로 비동기가 작업중이라면 그것보다 아래에 있는 작업이 있다면 동시에 실행시킨다.
          비동기가 더 오래걸리는 일이라면 아래쪽 작업이 먼저 끝나서 먼저 출력이 되는것??
          그렇다면 비동기함수라도 밑의 작업보다 더 짧은 작업이라면 먼저 출력이 되지 않을까한다.
          */

         /* 
          아래에서 setTimeout함수는 자체적으로 비동기함수이기에 실행까지 1초가 걸린다.

          밑의 '하니입니다.'는 바로 출력이 가능하기에

          출력: 안녕하세요
          ▶ setTimeout() => 1초카운트시작
          출력: 하니입니다.
          ▶ (1초카운트 끝)
          출력: 저는

          순으로 나온다.
           */
         console.log('안녕하세요')

         setTimeout(() => {
            console.log('저는')
         }, 1000)

         // 아래는 '테스트합니다의 시간을 999로 준다면' 1ms가 확실하게 차이가 나게되어 [테스트합니다.] => [저는] 순으로 나오나

         // 999.9999999999999로 1천보다는 작지만 1천에 근접하게 설정하였고
         // 두 setTimeout이 동시에 작업을 실시했다면 어떤 상황이여도 [테스트합니다.]가 먼저 나와야한다.

         // 실제 결과로는 [저는] => [테스트합니다.]순으로 출력이 되었다는 것은 비동기 함수의 실행 자체도 순차적으로 읽어내서 함수를 실행하고 다음 함수를 읽는다는것을 증명한다.
         // 첫번째 setTimeout을 실행시키고 두번째 setTimeout을 실행시키는 시간의 간격이 1000과 999.9999999999999의 간격보다 길기에 두번째는 첫번째 setTimeout에서부터 넘겨받는 시간이 합하여서 1000이 초과되어 첫번째 setTimeout이 실행된다는걸 실험을 통해 알게되었다.
         setTimeout(() => {
            console.log('테스트합니다.')
         }, 999.99999999999999)

         console.log('하니입니다.')
      </script>
   </body>
</html>
