<!DOCTYPE html>
<html lang="ko">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
   </head>
   <body>
      <script>
         /* 1. 체크퀴즈1번, 익명함수(이름없는), 비익명함수(이름있는) 함수 개념 */

         function hello1() {
            document.write('안녕하세요, 이름있는함수<br>')
         }

         // 밑에는 function [함수이름X] () {} 구조라서 이름이 없는 함수다.
         let hello2 = function () {
            document.write('안녕하세요, 이름없는함수')
         }

         hello1()
         hello2()
         //  end

         //   1, 4 9 16이 먼
         /* vla1에 1, 4, 9, 16이 먼저들어오면서
      retrun element * 2,,, 즉 2가 곱해진 리턴값을
      저장시킴 (2,8,18,32)
      그리고 이것들을 배열형태인 [2,8,18,32]형태로 val1에 저장시킴 */

         /*

      0. 콜백(callback) 함수
         - 다른 코드의 인수로서 넘겨주는 실행 가능한 코드
      
      1. forEach =  for역할로 사용할 때 (데이터수정x)
      
      2. map : 기존에 있는 배열에 데이터를 덧붙일 때
      
      3. filter : 기존의 배열에 내용을 걸러낼 때 
      
      4. 타임함수,,
      - setTimeout()
      - setInterval()
      -
      
      5. 즉시 실행 함수
      : 함수를 따로 실행하지 않고 정의만 해도 실행되는 함수
      : 소스코드 충돌을 피하기 위해서 사용
      
      6. 함수의 호이스팅
      비익명의 함수는 함수를 아래에서 선언해도 끌어올려서 사용할 수 있다.
      ** 비익명 함수 = 기명함수 = 이름 있는 함수
         구조: function 이름() {}
      ** 익명함수 = 이름 없는 함수
         구조: const 변수명 = function() {}
         함수뒤에 이름이 존재하지 않음

      ** 즉시실행함수 = 이름 없는 함수

      7. 함수의 스코프
      스코프(scope): 변수에 접근할 수 있는 범위
      
         1. 전역 스코프(global) : 어디서든 해당 변수에 접근 가능함

         2. 지역 스코프(local) :한정적인 범위에서 해당 변수 접근 가능
            - 함수 스코프
            - 블록 스코프
         2가지 종류

         3. 함수 스코프와 var
         : 함수 스코프에서 선언되면 전역에서 사용 불가능.

         function abc() {
            var aa = '12';
            ㄴ>함수 내부에서 선언
            }
         console.log(aa);
         ㄴ>Uncaught ReferenceError: aa is not defined

         var: 함수 내부에서만 지역변수로 유지됌, 만약 함수가 아닌 블록 스코프에서 선언하였다면 전역변수로 사용가능


         4. 블록 스코프와 const, let
         : 블록 스코프는 블록({})내부에서 선언된 변수는 해당 블록에서만 접근 가능한 걸 말한다.
         let, const로 선언된 변수가 블록 스코프 방식을 따른다.

         두가지 예시
         ▶ var
         function hello() {
         for (var i=0; i<12; i++) {
            ...
            }
            console.log(i)
            ㄴ>접근가능
         } hello();  //12


         ▶ let, const
         function hello() {
         for (let i=0; i<12; i++) {
            ...
            }
            console.log(i)
            ㄴ> 접근 불가능
         }
         hello();
         ㄴ: ReferenceError: i is not defined



         
      */

         /**** 궁금한거 찾아본것들
         reduce함수
         ▼ 구조1 (콜백함수가 포함되야함.)
         array.reduce (
            callback (
            accumulator, 
            currentValue,
            index,
            array
            )
         )
      ▼ 구조2 (요약)
      arr.reduce(callback[(4가지 구성요소), initialValue])
      

      accumulator - accumulator는 callback함수의 반환값을 누적합니다.
      currentValue - 배열의 현재 요소
      index(Optional) - 배열의 현재 요소의 인덱스
      array(Optional) - 호출한 배열
      accumlator에 원하는 인수들을 누적합산

      initialValue(Optional)
      : 최초 callback함수 실행 시 accumulator 인수에 제공되는 값, 초기값을 제공하지 않을경우 배열의 첫 번째 요소를 사용하고, 빈 배열에서 초기값이 없을 경우 에러가 발생합니다.
      */
      </script>
   </body>
</html>
